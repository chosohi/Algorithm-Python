# 지문 이해 및 풀이 계획 세우기
## 문제의 해결 - 예제
arr = 1 2 3 9 10 12

k = 7

1. 1 2 3 9 10 12 | 1+2*2 = 5 | 5 3 9 10 12
2. 3 5 9 10 12 | 3 + 5*2 = 13 | 13 9 10 12
3. 9 10 12 13 | K <= 9 |  ==> return 

## 알고리즘 복잡도
- 최악의 경우:
  - 수가 하나 남을때까지 섞어야 하는 경우(n-1회)
- 각 단계("섞는 일")에서 요구되는 계산량:
  - 정렬된 리스트에 순서 맞추어 원소 삽입
  - O(n)
- 전체 문제 풀이의 복잡도:
  - O(n^2)
  - 지나치게 높다.

## 보다 나은 방법
- 최소/최대 원소를 빠르게 꺼낼 수 있으면 좋은데..!
- 힙(heap)
  - max heap (최대 원소를 빠르게 꺼낼 수 있는 자료구조)
  - min heap (최소 원소를 빠르게 꺼낼 수 있는 자료구조)
## 힙(Heaps)
- 성질 : 최대/최소 원소를 빠르게 찾을 수 있음
  - 상수시간에 최대/최소 원소를 찾을 수 있다.
- 연산
  - 힙 구성(heapify) => O(NlogN)
  - 삽입(insert) => O(logN)
  - 삭제(remove) => O(logN)
## 힙의 구현 
- 완전 이진 트리(complete binary tree)
  - 배열을 이용해서 구현 가능! 
  - 인덱스로 자식 노드 찾아나가기 쉽다 -> 공간 효율성이 좋다
## 힙의 응용
- 정렬(heapsort)
- 우선 순위 큐(priority queue)
# 풀이 엿보기
## Python에서 힙 적용
### import heapq
### heapq.heapify(L)
리스트 L로부터 min heap 구성
### m = heapq.heappop(L)
min heap L 에서 최소값 삭제(반환)

m에는 L에서 최소값이 담겨져있음
### heapq.heappush(L, x)
min heap L에 원소 x 삽입

L은 여전히 min heap 구조 유지(log(N)이 걸림)

만약 리스트, 배열로 정렬하고 끼워넣는식으로 진행한다면
O(N2)이 될 것


